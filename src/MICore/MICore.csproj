<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="14.0" DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <Import Project="$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.props" Condition="Exists('$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.props')" />
  <Import Project="..\..\build\miengine.settings.targets" />
  <PropertyGroup>
    <MinimumVisualStudioVersion>14.0</MinimumVisualStudioVersion>
    <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
    <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
    <ProjectGuid>{54C33AFA-438D-4932-A2F0-D0F2BB2FADC9}</ProjectGuid>
    <OutputType>Library</OutputType>
    <AppDesignerFolder>Properties</AppDesignerFolder>
    <RootNamespace>MICore</RootNamespace>
    <AssemblyName>Microsoft.MICore</AssemblyName>
    <DefaultLanguage>en-US</DefaultLanguage>
    <FileAlignment>512</FileAlignment>
    <ProjectTypeGuids>{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}</ProjectTypeGuids>
    <OutputPath>$(MIDefaultOutputPath)</OutputPath>
    <DocumentationFile>$(DropRootDir)\ReferenceAssemblies\$(AssemblyName).xml</DocumentationFile>
    <!-- Disable warning about public API without XML documentation: it would be nice if MICore had documentation 
    for all its methods, but it is also not a public assembly, and adding XML documentation for all its methods
    would take a fair amount of work.-->
    <NoWarn>$(NoWarn);1591</NoWarn>
  </PropertyGroup>
  
  <PropertyGroup Condition="'$(IsCoreClr)' == 'true'">
    <ProjectTypeGuids>$(ProjectTypeGuids);{786C830F-07A1-408B-BD7F-6EE04809D6DB};</ProjectTypeGuids>
    <TargetFrameworkVersion>v5.0</TargetFrameworkVersion>
  </PropertyGroup>

  <PropertyGroup Condition="'$(IsCoreClr)' == 'false'">
    <TargetFrameworkVersion>v4.5</TargetFrameworkVersion>
  </PropertyGroup>  
  
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' ">
    <DebugSymbols>true</DebugSymbols>
    <DebugType>full</DebugType>
    <Optimize>false</Optimize>
    <DefineConstants>$(DefineConstants);DEBUG;TRACE</DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
    <Prefer32Bit>false</Prefer32Bit>
    <RunCodeAnalysis>true</RunCodeAnalysis>
    <CodeAnalysisRuleSet>..\IDECodeAnalysis.ruleset</CodeAnalysisRuleSet>
    <TreatWarningsAsErrors>true</TreatWarningsAsErrors>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">
    <DebugType>pdbonly</DebugType>
    <Optimize>true</Optimize>
    <DefineConstants>$(DefineConstants);TRACE</DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
    <Prefer32Bit>false</Prefer32Bit>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)' == 'Debug.Desktop|AnyCPU'">
    <DebugSymbols>true</DebugSymbols>
    <DebugType>full</DebugType>
    <Optimize>false</Optimize>
    <DefineConstants>$(DefineConstants);DEBUG;TRACE</DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
    <Prefer32Bit>false</Prefer32Bit>
    <RunCodeAnalysis>true</RunCodeAnalysis>
    <CodeAnalysisRuleSet>..\IDECodeAnalysis.ruleset</CodeAnalysisRuleSet>
    <TreatWarningsAsErrors>true</TreatWarningsAsErrors>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)' == 'Release.Desktop|AnyCPU'">
    <DebugType>pdbonly</DebugType>
    <Optimize>true</Optimize>
    <DefineConstants>$(DefineConstants);TRACE</DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
    <Prefer32Bit>false</Prefer32Bit>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)' == 'Lab.Debug|AnyCPU'">
    <DebugSymbols>true</DebugSymbols>
    <DefineConstants>$(DefineConstants);DEBUG;TRACE</DefineConstants>
    <DebugType>full</DebugType>
    <PlatformTarget>AnyCPU</PlatformTarget>
    <ErrorReport>prompt</ErrorReport>
    <CodeAnalysisRuleSet>MinimumRecommendedRules.ruleset</CodeAnalysisRuleSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)' == 'Lab.Release|AnyCPU'">
    <DefineConstants>$(DefineConstants);TRACE</DefineConstants>
    <Optimize>true</Optimize>
    <DebugType>pdbonly</DebugType>
    <PlatformTarget>AnyCPU</PlatformTarget>
    <ErrorReport>prompt</ErrorReport>
    <CodeAnalysisRuleSet>MinimumRecommendedRules.ruleset</CodeAnalysisRuleSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)' == 'Debug-PortablePDB|AnyCPU'">
    <DebugSymbols>true</DebugSymbols>
    <DebugType>portable</DebugType>
    <Optimize>false</Optimize>
    <DefineConstants>$(DefineConstants);DEBUG;TRACE</DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
    <Prefer32Bit>false</Prefer32Bit>
    <RunCodeAnalysis>true</RunCodeAnalysis>
    <CodeAnalysisRuleSet>..\IDECodeAnalysis.ruleset</CodeAnalysisRuleSet>
  </PropertyGroup>
  <ItemGroup Condition="'$(IsCoreClr)' == 'true'">
    <None Include="project.json" />
    <!-- A reference to the entire .NET Framework is automatically included -->
  </ItemGroup>
  <ItemGroup Condition="'$(IsCoreClr)' == 'false'">
    <Reference Include="System" />
    <Reference Include="System.Xml" />
    <Reference Include="Microsoft.VisualStudio.Debugger.InteropA">
      <HintPath>$(NuGetPackagesDirectory)/Microsoft.VisualStudio.Debugger.Interop.Portable.1.0.1/lib/portable-net45+net46+dnxcore50/Microsoft.VisualStudio.Debugger.InteropA.dll</HintPath>
    </Reference>
  </ItemGroup>
  <ItemGroup>
    <ProjectReference Include="..\DebugEngineHost.Stub\DebugEngineHost.Stub.csproj">
      <Project>{ea876a2d-ab0f-4204-97dd-dfb3b5568978}</Project>
      <Name>DebugEngineHost.Stub</Name>
      <Private>False</Private>
    </ProjectReference>
    <ProjectReference Include="..\prebuild\prebuild.csproj">
      <Project>{95C0421F-D4C1-46E8-9177-6DAA4D71D0F2}</Project>
      <Name>Prebuild</Name>
      <ReferenceOutputAssembly>false</ReferenceOutputAssembly>
    </ProjectReference>    
  </ItemGroup>
  <PropertyGroup>
    <XsdCodeFile Condition="'$(IsCoreClr)' == 'true'">LaunchOptions.xsd.types.designer.cs</XsdCodeFile>
    <XsdCodeFile Condition="'$(IsCoreClr)' == 'false'">LaunchOptions.xsd.types.designer.desktop.cs</XsdCodeFile>
  </PropertyGroup>
  <ItemGroup>
    <None Include="LaunchOptions.xsd" />
    <None Include="SetMIDebugLogging.cmd" />
    <None Include="ValidateDesignerFile.cmd" />
    <None Include="PostProcessXsdOutput.cmd" />
  </ItemGroup>
  <ItemGroup>
    <Compile Include="CommandFactories\clrdbg.cs" />
    <Compile Include="CommandFactories\gdb.cs" />
    <Compile Include="CommandFactories\lldb.cs" />
    <Compile Include="CommandFactories\MICommandFactory.cs" />
    <Compile Include="CommandLock.cs" />
    <Compile Include="Debugger.cs" />
    <Compile Include="ExceptionHelper.cs" />
    <Compile Include="InvalidCoreDumpOperationException.cs" />
    <Compile Include="InvalidLaunchOptionsException.cs" />
    <Compile Include="LaunchCommand.cs" />
    <Compile Include="LaunchOptions.cs" />
    <Compile Include="$(XsdCodeFile)">
      <AutoGen>True</AutoGen>
      <DependentUpon>LaunchOptions.xsd</DependentUpon>
    </Compile>
    <Compile Include="Logger.cs" />
    <Compile Include="MICoreResources.Designer.cs">
      <AutoGen>True</AutoGen>
      <DesignTime>True</DesignTime>
      <DependentUpon>MICoreResources.resx</DependentUpon>
    </Compile>
    <Compile Include="MIException.cs" />
    <Compile Include="MIResults.cs" />
    <Compile Include="LinuxNativeMethods.cs" />
    <Compile Include="PlatformUtilities.cs" />
    <Compile Include="Properties\AssemblyInfo.cs" />
    <Compile Include="Transports\ClientServerTransport.cs" />
    <Compile Include="Transports\ITransport.cs" />
    <Compile Include="Transports\LocalTransport.cs" />
    <Compile Include="Transports\LocalLinuxTransport.cs" />
    <Compile Include="Transports\MockTransport.cs" />
    <Compile Include="Transports\PipeTransport.cs" />
    <Compile Include="Transports\ServerTransport.cs" />
    <Compile Include="Transports\StreamTransport.cs" />
    <Compile Include="Transports\TcpTransport.cs" />
  </ItemGroup>
  <ItemGroup>
    <Content Include="ExampleLaunchOptions.xml" />
  </ItemGroup>
  <ItemGroup>
    <EmbeddedResource Include="MICoreResources.resx">
      <Generator>PublicResXFileCodeGenerator</Generator>
      <LastGenOutput>MICoreResources.Designer.cs</LastGenOutput>
      <SubType>Designer</SubType>
    </EmbeddedResource>
  </ItemGroup>
  <ItemGroup>
    <GlassDirCopy Include="$(OutDir)$(AssemblyName)$(TargetExt)" />
    <GlassDirCopy Include="$(OutDir)$(AssemblyName).XmlSerializers.dll" Condition="'$(Configuration)'!='Debug-PortablePDB'" />
  </ItemGroup>
  
  <ItemGroup />
  <Import Condition="'$(IsCoreClr)' == 'true'" Project="$(MSBuildExtensionsPath32)\Microsoft\Portable\$(TargetFrameworkVersion)\Microsoft.Portable.CSharp.targets" />
  <Import Condition="'$(IsCoreClr)' == 'false'" Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" />
  <Import Project="..\..\build\miengine.targets" />
  
  <!-- This is a target file used to generate + validate LaunchOptions.xsd.types.designer.cs. The way this works is that we have a baseline
  file checked in. This target will create a new one, and if it is different from the baseline, it will update the baseline.
  NOTE: We skip this step for the lab configuration to ensure that in the lab we build exactly what is checked in.-->
  <Target Name="BeforeBuild" 
          Inputs="LaunchOptions.xsd;ValidateDesignerFile.cmd;PostProcessXsdOutput.cmd" 
          Outputs="$(IntermediateOutputPath)LaunchOptions.xsd.types.designer-candidate.cs" 
          Condition="!$(Configuration.Contains('Lab.'))">
    <!-- First validate the tools we need are where we expect -->
    <Error Condition="'$(SDK40ToolsPath)'==''" Text="SDK40ToolsPath msbuild property is undefined." />
    <Error Condition="!Exists('$(SDK40ToolsPath)xsd.exe')" Text="xsd.exe does not exist in the SDK40ToolsPath ($(SDK40ToolsPath)xsd.exe)." />
    
    <!-- Convert the .xsd -> types -->
    <MakeDir Condition="!Exists('$(IntermediateOutputPath)')" Directories="$(IntermediateOutputPath)" />
    <PropertyGroup>
      <XsdParameters>&quot;LaunchOptions.xsd&quot; /classes /namespace:$(RootNamespace).Xml.LaunchOptions </XsdParameters>
      
      <!-- Mono's XSD.exe uses /outputdir instead of /out -->
      <XsdParameters Condition="'$(IsMonoRuntime)' == 'false'">$(XsdParameters) /out:&quot;$(IntermediateOutputPath).&quot;</XsdParameters>
      <XsdParameters Condition="'$(IsMonoRuntime)' == 'true'">$(XsdParameters) /outputdir:&quot;$(IntermediateOutputPath).&quot;</XsdParameters>
      <XsdParameters Condition="'$(IsCoreClr)' == 'true'">$(XsdParameters) /fields</XsdParameters>
     
      <XsdCandidateFile>$(IntermediateOutputPath)LaunchOptions.cs</XsdCandidateFile>
      
      <XsdCodeFile Condition="'$(IsCoreClr)' == 'true'">LaunchOptions.xsd.types.designer.cs</XsdCodeFile>
      <XsdCodeFile Condition="'$(IsCoreClr)' == 'false'">LaunchOptions.xsd.types.designer.desktop.cs</XsdCodeFile>
    </PropertyGroup>
       
    <Exec Command="&quot;$(SDK40ToolsPath)xsd.exe&quot; $(XsdParameters)" />
    
    <!-- Remove non-portable attributes if we're building for CoreCLR -->
    <PropertyGroup>
      <LineEndingRegex>\r\n|\n|\r</LineEndingRegex>
      <SerializableRegex>^.*\[System.SerializableAttribute\(.*[$(LineEndingRegex)]+</SerializableRegex>
      <DesignerCategoryRegex>^.*\[System.ComponentModel.DesignerCategoryAttribute\(.*[$(LineEndingRegex)]+</DesignerCategoryRegex>
      
      <CandidateFileContents>$([System.IO.File]::ReadAllText($(XsdCandidateFile)))</CandidateFileContents>
      <CandidateFileContents>$([System.Text.RegularExpressions.Regex]::Replace($(CandidateFileContents), $(SerializableRegex), "", RegexOptions.Multiline))</CandidateFileContents>
      <CandidateFileContents>$([System.Text.RegularExpressions.Regex]::Replace($(CandidateFileContents), $(DesignerCategoryRegex), "", RegexOptions.Multiline))</CandidateFileContents>
    </PropertyGroup>
    
    <WriteLinesToFile Condition="'$(IsCoreClr)' == 'true'"
                      File="$(XsdCandidateFile)"
                      Lines="$(CandidateFileContents)"
                      Overwrite="true" />    
    
    <!-- Update the checked-in types designer file if it is out of date -->
    <Message Text="Comparing '$(XsdCandidateFile)' to '$(XsdCodeFile)'" />
    <PropertyGroup>
      <!-- Read files from disk, remove comments, normalize whitespace, and account for differences in Mono XSD.exe -->
      <LineEndingRegex>\r\n|\n|\r</LineEndingRegex>
      <CommentRegex>^\s*//.*[$(LineEndingRegex)]+</CommentRegex>      
      <GeneratedCodeRegex>^.*\[System.CodeDom.Compiler.GeneratedCodeAttribute\(.*[$(LineEndingRegex)]+</GeneratedCodeRegex>
      <UsingRegex>^\s*using.*[$(LineEndingRegex)]+</UsingRegex>
      
      <CandidateFileContents>$([System.IO.File]::ReadAllText($(XsdCandidateFile)))</CandidateFileContents>
      <CandidateFileContents>$([System.Text.RegularExpressions.Regex]::Replace($(CandidateFileContents), $(CommentRegex), "", RegexOptions.Multiline))</CandidateFileContents>
      <CandidateFileContents>$([System.Text.RegularExpressions.Regex]::Replace($(CandidateFileContents), $(LineEndingRegex), "%0D%0A", RegexOptions.Multiline))</CandidateFileContents>
      <CandidateFileContents>$([System.Text.RegularExpressions.Regex]::Replace($(CandidateFileContents), $(GeneratedCodeRegex), "", RegexOptions.Multiline))</CandidateFileContents>
      <CandidateFileContents>$([System.Text.RegularExpressions.Regex]::Replace($(CandidateFileContents), $(UsingRegex), "", RegexOptions.Multiline))</CandidateFileContents>
      
      <CurrentFileContents>$([System.IO.File]::ReadAllText($(XsdCodeFile)))</CurrentFileContents>
      <CurrentFileContents>$([System.Text.RegularExpressions.Regex]::Replace($(CurrentFileContents), $(CommentRegex), "", RegexOptions.Multiline))</CurrentFileContents>
      <CurrentFileContents>$([System.Text.RegularExpressions.Regex]::Replace($(CurrentFileContents), $(LineEndingRegex), "%0D%0A", RegexOptions.Multiline))</CurrentFileContents>
      <CurrentFileContents>$([System.Text.RegularExpressions.Regex]::Replace($(CurrentFileContents), $(GeneratedCodeRegex), "", RegexOptions.Multiline))</CurrentFileContents>
      <CurrentFileContents>$([System.Text.RegularExpressions.Regex]::Replace($(CurrentFileContents), $(UsingRegex), "", RegexOptions.Multiline))</CurrentFileContents>
      
      <ContentsEqual>$([System.String]::Equals($(CandidateFileContents), $(CurrentFileContents), StringComparison.Ordinal))</ContentsEqual>
    </PropertyGroup>
    
    <!-- If the files don't match, replace the checked-in copy with the candidate -->
    <Message Condition="'$(ContentsEqual)' == 'false'"
             Text="Updating $(XsdCodeFile)" />
    <Copy Condition="'$(ContentsEqual)' == 'false'"
          SourceFiles="$(XsdCandidateFile)"
          DestinationFiles="$(XsdCodeFile)" />
  </Target>
  
  <!-- This target is used to generate an XML serializers assembly for the types in LaunchOptions.xsd. We can't embed these types
  into MICore as CoreCLR doesn't expose the types needed to make that code work.
  NOTE: We don't do this in the Debug-PortablePDB configuration as having this file messes up unix, and when we use 'InstallToVSCode link'
  the CLR will try and load the assembly directly from the output directory. -->
  <Target Name="GenerateXmlSerializersAssembly" AfterTargets="Compile" Inputs="$(XsdCodeFile);$(AssemblyOriginatorKeyFile)" Condition="'$(Configuration)'!='Debug-PortablePDB'" Outputs="$(IntermediateOutputPath)sgen/$(AssemblyName).XmlSerializers.dll">
    <PropertyGroup>
      <SerializationSigningCompilerOptions>/keyfile:$(AssemblyOriginatorKeyFile)</SerializationSigningCompilerOptions>
      <SerializationSigningCompilerOptions Condition="'$(DelaySign)'=='true'">$(SerializationSigningCompilerOptions) /delaysign</SerializationSigningCompilerOptions>
      
      <CompilerPath>$(CscToolPath)$(CscToolExe)</CompilerPath>
      <CompilerPath Condition="'$(CompilerPath)' == ''">$(MSBuildBinPath)\csc.exe</CompilerPath>
      
      <RefPath Condition="'$(IsMonoRuntime)' == 'false'">$(MSBuildFrameworkToolsPath)</RefPath>
      <RefPath Condition="'$(IsMonoRuntime)' == 'true'">$(SDK40ToolsPath)</RefPath>
    </PropertyGroup>
    
    <Error Condition="'$(SDK40ToolsPath)'==''" Text="SDK40ToolsPath msbuild property is undefined." />
    <Error Condition="!Exists('$(SDK40ToolsPath)sgen.exe')" Text="sgen.exe does not exist in the SDK40ToolsPath ($(SDK40ToolsPath)xsd.exe)." />
    
    <RemoveDir Condition="Exists('$(IntermediateOutputPath)sgen')" Directories="$(IntermediateOutputPath)sgen" />
    <MakeDir Directories="$(IntermediateOutputPath)sgen" />
    
    <!-- Compile the types file into an assembly that we can use as input to sgen. We don't want to pass our real assembly as we have some things that sgen doesn't like. -->
    <Exec Command="&quot;$(CompilerPath)&quot; LaunchOptions.xsd.types.designer.cs $(GeneratedAssemblyInfoFile) /out:$(IntermediateOutputPath)sgen/$(AssemblyName).dll /target:library /noconfig $(SerializationSigningCompilerOptions) /r:$(RefPath)/System.dll /r:$(RefPath)/System.Xml.dll" />
    
    <!-- Now generate the serialization assembly -->
    <Exec Command="&quot;$(SDK40ToolsPath)sgen.exe&quot; $(IntermediateOutputPath)sgen/$(AssemblyName).dll /force /compiler:&quot;$(SerializationSigningCompilerOptions)&quot; /keep" />
  </Target>
  
  <!-- To get the seralization assembly copied to the vsix, and also to the output directory, we have this target
  which adds the XmlSerializers as if it was a source item in our project with a 'CopyToOutputDirectory' child
  node. See the 'GetCopyToOutputDirectoryItems' target in C:\Program Files (x86)\MSBuild\14.0\Bin\Microsoft.Common.CurrentVersion.targets
  for more info. -->
  <Target Name="AddXmlSerializersAssemblyToOutputGroup" BeforeTargets="GetCopyToOutputDirectoryItems" Condition="'$(Configuration)'!='Debug-PortablePDB'">
    <ItemGroup>
      <_GenerateXmlSerializersAssemblyOutput Include="$(IntermediateOutputPath)sgen/$(AssemblyName).XmlSerializers.dll" />
      <_SourceItemsToCopyToOutputDirectoryAlways Include="@(_GenerateXmlSerializersAssemblyOutput->'%(FullPath)')">
        <TargetPath>$(AssemblyName).XmlSerializers.dll</TargetPath>
      </_SourceItemsToCopyToOutputDirectoryAlways>
    </ItemGroup>
  </Target>
</Project>